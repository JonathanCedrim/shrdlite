We started to implement a partial order planner as an advanced planning
algorithm but got stuck at a half-finished state. 

The basic building blocks of this algorithm are move actions with their 
preconditions and effects. A partial order of the actions and causal links 
between effects and preconditions.

A move action specifies a move of an object from one position to another position
by say√≠ng what has to be true before it can execute and what is true after. 
The proconditions and effects are represented as conjuncts of simple predicates such as 
(ball ontoop box), (box1 < box2) etc.
The actions are variable and can thus mold in to any wanted move action that fit the constraints.
We use a different move action depending on the relation of the goal (beside, above ...)
We illustrate with the move action for goals with relation leftof or rightof.

move obj from a to b 
pre: 
  (obj ontop a) (clear obj) (clear b) 
  (not-eq obj a) (not-eq obj b) (not-eq a b) (physical laws constraints)
eff: 
  (obj ontop b) (not (obj ontop a)) (clear a) (not (clear a))
  
  when (a < b) --> (obj > a) (not (obj < b))
  when (a > b) --> (obj < a) (not (obj > b))
  
  for all objects x except obj,a and b
  when (a < x < b) --> (x < obj)    
  when (b < x < a) --> (x > obj)

when - Conditional effect 
       The right hand side is an effect if the lhs is true before the action executes  
  
The algorithm works by firstly setting up a start state (as an action that precedes
every other action, has no preconditions and has the start state as it's effects)
and a goal state (as an action thet procedes every other action with the
goal as an precondition and nothing as it's effects)
The goal conjunct is then put on the agenda (a queue of precondition conjuncts we want 
to satisfy)

We call the algorithm with this so called null plan
A high-level rough description of the algorithm follows
1)
  Choose a goal on the agenda, if it's empty and all variables have been assigned 
  values, we're successfull.
2)
  Try to instanciate or choose an already existing action that has 
  in it's effects, a conjunct that can unify with the goal conjunct given 
  existing variable assignments, non-codesignation constraints and physical laws constraints. 
  If the chosen effect is conditional, add its lhs to the agenda unless
  it's already been used in a link.
  Order the chosen action before the goal action.
  Draw a causal link between the effect satisfying the goal and the goal
  If we instansiated a new action, put all it's precondition conjuncts on the agenda.
  (Except the non codesignation constraints)  
3)
  We now check if any causal link is potentially interfering with any action.
  If we find that an action who's effects negate a causal link is not surely ordered
  before or after that causal link then we must either move the action before or after the 
  causal link. 
4)
  Recursively invoke algorithm

(If we have no satisfying choices at any 'choice point', we backtrack)
  
If the algorithm returns successfully then we have a consistent ordering of move actions
leading from start to goal state.

This above is the proposed algorithm which we intended to implement.
At this moment the algorithm cannot yet fully handle variable actions, advanced goals (not treated
above either), conditional effects and only the relation ontop is supported. 








WORK 

I was together with everybody else in the group involved in building the first version. 
The one that satisfied the basic requirements.
I was the sole contributor of the partial order planner extension.



