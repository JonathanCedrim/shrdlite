%
% File eacl2014.tex
%
% Contact g.bouma@rug.nl yannick.parmentier@univ-orleans.fr
%
% Based on the instruction file for ACL 2013 
% which in turns was based on the instruction files for previous 
% ACL and EACL conferences

%% Based on the instruction file for EACL 2006 by Eneko Agirre and Sergi Balari
%% and that of ACL 2008 by Joakim Nivre and Noah Smith

\documentclass[11pt]{article}
\usepackage{eacl2014}
\usepackage{times}
\usepackage{url}
\usepackage{latexsym}
\usepackage[utf8]{inputenc}
\special{papersize=210mm,297mm} % to avoid having to use "-t a4" with dvips 
%\setlength\titlebox{6.5cm}  % You can expand the title box if you really have to

\title{Report for Artificial Intelligence TIN 172}

\author{Robert Hangu\\\And
  Simon Lindfors\\\And
  Santiago Munín González\\\And
  Carlos Tomé
   }

\date{\today}

\begin{document}
	\maketitle
	\begin{abstract}

		This document describes the design and implementation of Shrdlite. This 
		is a smaller version of the Shrdlu game, which is used in the 
		laboration of the Artificial Intelligence (TIN172) course at Chalmers.

	\end{abstract}

	% ==========================================================================
	\section{Description}
	
	The game Shrdlu consists of a two-dimensional world containing object 
	stacks. These can be picked up and let down by a robot arm which acts 
	intelligently. 

	The objects have different shapes, sizes and colors. The robot may only 
	perform actions which obey physical laws, such as not putting a big object 
	into a small box or not stacking anything onto of a ball.

	Utterances can be given to the robot through a web interface, which tell it 
	what objects to move where. The robot arm then finds a way of rearranging 
	the objets in order to fulfill the user input.

	% ==========================================================================
	\section{Project}

	The purpose of the project is to implement a backend for the robot 
	arm. It receives the input, which is processed by the engine and 
	generates a list of actions that the robot must perform in order to achieve 
	the desired outcome. \\
	
        Along with this, we have implemented a number of extensions that 
        allows us to treat more interesting examples.  \\

        This extensions are: \\

        \begin{itemize}
          \item Complete quantifier handling.  \\

          \item Object disambiguation. \\ 

          \item Dynamic suggestions.  \\

          \item Complex world handling.  \\

        \end{itemize}

        Moreover we tried to implement a Partial-Order planner but we didn't have 
        time enough to finish it.  Anyway we have a draft version of the 
        implementation and a complete description on how we could have finish 
        it.  \\

	\subsection{Design}

	The top-level design is split into two main phases: interpretation and 
	planning.

	Interpretation deals with the parsed user input and delivers some goals 
	according to the input, that are contextualized to the world. For e.g. for the 
	input ``put the blue ball in the red box'', this should generate a goal 
	which matches all blue balls to all red boxes.
	
	Once the goals are generated, they are passed to the actual planner, which 
	outputs a list of basic actions.

	\subsubsection{World and Goal representation.}
        
        For simple cases a goal is represented either as a relation that must 
        hold between two objects, or as the fact that the arm must hold 
        a object.  \\

\begin{verbatim}
Goal = MoveObj Id Relation Id
     | TakeObj Id 
\end{verbatim}

        This simple representation is enough to handle all cases where the ``the'' and
        ``any'' quantifiers are involved.  \\

        But we wanted to handle ``all'' quantifiers so we had to add the notion of 
        composed goal (this is, \textit{put all balls
        in a box} should generate a goal composed by all the boxes in some box). For 
        this purpose, we extend the goal datatype with two more clauses.  \\

\begin{verbatim}
Goal = And [Goal]
     | Or [Goal]
     | MoveObj Id Relation Id
     | TakeObj Id 
\end{verbatim}

As for the world representation, we defined the following record:
\begin{verbatim} 
WorldState = 
  { _holding     :: Maybe Id
  , _positions   :: M.Map Id (Int, Int)
  , _world       :: [[Id]]
  , _objectsInfo :: M.Map Id Object } 
\end{verbatim}

A state in the state space is the combination of \texttt{\_holding} (if any object is holded by the arm and which), \texttt{\_positions} (position of every object) and \texttt{\_world} (a list of stacks representing just the ids of the objects of the world). Note that \texttt{\_objectsInfo} does not belongs to a state in the search space 
remains the same through the whole program).
  
  \section{Interpretation}
  This is the phase executed after the parsing and before the planning. Its responsibility is to translate a 
  parse tree into a goal (or a set of goals) and solve possible ambiguity problems. Details about these two steps 
  can be found in some of the next extension sections.

  In a nutshell, it tries to find all the objects refered by the utterance sent to the system and return a list of
  goals that are actually possible. If more than one goal is found, then it tries to solve the ambiguity by 
  suggesting to the user more concrete sentences.


  \section{Planning}
  This phase tries to satisfy a given goal. It can use two different search methods (breadth-first search and A*). At every state, it find all possible next states (discarding those who were already checked) and keeps going 
  until it satisfies the goal. Note than if A* is used, the heuristics described in following sections help to 
  follow a potentially good path instead of just checking every possibility.

  In order to generate all the possible next states, we use a function\footnote{Quite easy to implement 
  since the only movement we have to take care of is dropping an object on top of another} 
  which finds out if a movement if possible and, in that case, the resulting world of doing so is added.

	% ==========================================================================
	\section{Extensions}

	\subsection{Handling of quantifiers}

          The basic project just requires to handle the all quantifier.
          That means it is enough to detect the list of objects matching the description
          (and the list of objects matching the destination if the goal is \texttt{Move},
          merging them later).

          For this extension, we have to correctly process all the quantifiers:

          \begin{itemize}
            \item {\bf The}: this can lead to an ambiguity ("the ball" implies there has
            to be only one ball, otherwise it is an ambiguity error).
            \item {\bf Any}: this is how we processed all before (this is, just pick one
            among all the matches).
            \item {\bf All}: we changed this, so now it actually matches everything 
            (we will explain this during in the following section).
          \end{itemize}

          \subsubsection{Composed goals}
          Now we need to handle with composed goals (this is, \textit{put all balls
          in a box} should generate a goal composed by all the boxes in some box). For 
          this purpose, we redefine the goal datatype:

\begin{verbatim}
data Goal = And [Goal]
     | Or [Goal]
     | MoveObj Id Relation Id
     | TakeObj Id deriving (Eq, Show)
\end{verbatim}

          We don't think there is much room for explanation here, a goal is either 
          taking an object or moving it, or a set of those. There are two kinds of 
          sets, the \texttt{and} (conjuction) and the \texttt{or} (disjunction).

          Let's go back again to the list of quantifiers and relate them to the goals.

          \begin{itemize}
            \item {\bf The}: this generates a single goal (represented as a disjunctive
            list of one element). Useful to generate all the goals in an easy way
            (explained on the next code snippet).
            \item {\bf Any}: this generates a disjunctive goal.
            \item {\bf All}: this generates a conjunctive goal.
          \end{itemize}

          However, this is not that simple, what happens when we have something like 
          \textit{put the blue ball in a box}. This should generate a disjunctive goal
          composed of all the possible goals involving the blue ball in a box. Let's say
          we have, in our world, a blue ball \textit{b} and two boxes \textit{b1} and \textit{b2}. The goal would be something like:

\begin{verbatim}
  Or [MoveObj b Ontop b1
  , MoveObj b Ontop b2]
\end{verbatim}

          After some struggling, we came up with an easy solution to this problem, using list comprehensions.
          First, we have to select the operators using the quantifiers, and then generate all the valid possibilities.

\begin{verbatim}
let locList = matchingLocations
    objList = matchingObjects
in
  [fstOperator $
    [sndOperator $ 
      [MoveObj id1 rel id2
      | (rel, id2) <- locList
      , validMovement 
          objects id1 id2 rel]
  | id1 <- objList] ]
\end{verbatim}
	
        \subsection{Ambiguity resolution}
          The approach here was to modify the \texttt{findEntities} function so it can return
           either a list of matches or a list of conflicts. As an example, if we have two 
           balls and receive the utterance "take the ball", then we have a conflict because 
           we are requiring an specific object (using the quantifier \texttt{the}) and there
           exist two objects matching the description.

          If the interpreter doesn't find any ambiguity then the goal is sent to the planner 
          and everything goes on as before. However, if any ambiguity is found, then the 
          list of ids is sent to another function which tries to remove the disambiguity 
          (this is, giving unique descriptions to every id). After finding unique 
          descriptions, they are sent as a response and showed in a pop up to the user.

          Due to time issues we are not solving all the ambiguity conflicts. It works really well
          with ambiguity interpreting one parse tree, but it doesn't handle ambiguities coming from 
          the interpretation of different parse trees.

          \subsubsection{Unique identification of objects}
          TODO

        \subsection{Handling bigger worlds}
        The breadth-first search strategy worked well at first: we were getting solutions 
        fairly quick in most cases. However, after making sure we could handle the small 
        world, we moved to the medium and complex examples and here we got a lot of 
        timeouts (even though we raised from 5 to 50 seconds the time frame).

        The problem was we had to explore too many states in order to find a solution. The 
        number of possible states in these worlds is huge so we needed a way of
        prioritizing some states. The first that came up to our minds were some
        heuristics functions, thus we started thinking about the different cases
        and created some functions to use with the A* algorithm. We struggled a little
        bit at the beginning since due to some mistakes some of our heuristic functions
        were overstimating (so they weren't admissibles).
        
        \subsubsection{Proposed heuristics}
        In this section we describe briefly the implemented heuristics (check the code for
         further information, concretely the \texttt{Plan.hs} file). We defined different 
         heuristics for different relations (we didn't feel it was necessary to use them 
         for just taking an object or putting it back since the computation time took by the
         functions was not worth it). In the following definitions, we will refer to the 
         following terms:

         \begin{itemize}
          \item Object: the first part of the relation.
          \item Destination: the second part of the relation.
          \item $ontop(obj)$: function returning the number of objects above the argument.
          \item $highestPossible(source, destination)$: returns the highest object 
          above $destination$ such as it could contain/hold $source$.
         \end{itemize}

         Using this functions we can now explain the heuristics:

        \begin{itemize}
          \item {\bf Object On top/Inside Destination}: 
            $2 * (ontop(object) + ontop(destination)$
          \item {\bf Object Above Destination}:
            $2 * (ontop(object) + (ontop(destination) - highestPossible(object, destination)$
          \item {\bf Object LeftOf Destination}: calculate how costly is to put $object$ 
          and $destination$ in each column. Pick the combination which fulfills the 
          condition with the minor cost.
          \item {\bf Object Beside Destination}: same case as above, but now the columns 
          have to be adjacent.
          \item {\bf Object RightOf Destination}: call the left case reversing the 
          arguments.
          \item {\bf Under}: call Above reversing the arguments.
        \end{itemize}

        Recall that these are not the exact functions, since we also have to deal with 
        special cases that are not detailed here in order to keep the explanation simple 
        but that can be checked in the source code. Note too, that the $2 *$ operation is
        required since to move an object from one location to another it is necessary to 
        pick it and drop it (so two operations).

        \subsubsection{Efficiency of the heuristics}
        In order to check how useful were the heuristics we did some tests using the example worlds 
        and we found some interesting speed up in some cases (table~\ref{table}). Note, however, that the 
        calculation of the heuristics adds an important overhead so some of them may not be that good.

        On the other hand we found some examples for which the heuristics weren't useful at all, 
        but we think that, overall, they were totally worth it.

\begin{table*}[t]
    \begin{tabular}{|l|l|l|l|l|}
    \hline
    World   & Utterance                                               & A*     & BFS     & Improvement\\ \hline
    Small   & put the white ball in a box on the floor                & 13     & 141     & 984.61\%   \\ \hline
    Small   & move all balls inside a large box                       & 130    & 145     & 11.53\%    \\ \hline
    Small   & put all boxes on the floor                              & 62     & 75      & 20.96\%    \\ \hline
    Medium  & move the large ball inside a yellow box on the floor    & 17     & 11633   & 68329.41\% \\ \hline
    Medium  & move all bricks on a table                              & 46263  & 193239  & 317.70\%   \\ \hline
    Medium  & move all balls inside a large box                       & 91235  & 191687  & 110.10\%   \\ \hline
    Medium  & put the brick that is to the left of a pyramid in a box & 9      & 257     & 2755.55\%  \\ \hline
    Complex & put all balls in a large box                            & 498    & 1035    & 107.83\%   \\ \hline
    Complex & put all boxes on the floor                              & 393788 & 969239  & 146.13\%   \\ \hline
    Complex & put all red objects on the floor                        & 274328 & 599034  & 118.36\%   \\ \hline
    \end{tabular}
    \caption{Efficiency of the heuristics (using A*) versus BFS (comparing the number of states travelled)}
    \label{table}
\end{table*}
        \subsection{Suggestions}

        We came up with the idea of suggesting the user some interesting sentences. This is, we want 
        to prove to the user our system can handle difficult tasks. In order to do this, we first needed 
        to find a way to measure how hard a goal was without actually solving it (otherwise it would be 
        prohitibely slow). We realised that the already implemented heuristics were a good tool, so we decided 
        to use them.

        The idea is the following: we generate a bunch of possible goals (not extremely complicated, composed 
        of a simple movement) and we calculate the heuristics for them. After that, we just select the ones with 
        the highest heuristics (so they're likely to be harder).
	\subsection{Partial order planning}

	% ==========================================================================
	\section{Conclusions}

\newpage
\appendix
\section{Individual report: Santiago Munín González}
The project was built during our group meetings, so I can't say I did something on my own althought I 
was the main contributor of some pieces of the project.

\subsection{Basic project}

Here, I focused mostly on the interpretation and did small contributions on the planning (like bug fixing and 
helping with some functions). During this phase I done some functions to check if a relationship is valid, 
objects/locations matching and filtering, etc.

\subsection{Extension: Quantifiers}

This was the part I was most involved in. I struggled a little 
bit until I found a simple and elegant way of accomplishing the task. They're working really well (talking about both functionality and performance).

\subsection{Extension: Planning for bigger or more complex worlds}

I've been involved in the design and implementation of the heuristics used by the planner as well as in some 
bugfixing and testing.

\subsection{Extension: Suggestions}

We developed this between Carlos, Robert and me during one of our meetings.

\subsection{Extension: Disambiguity}

I modified the interpreter so it reports the list of object ids which cause a conflict (this is, 
when we look for an object description using the quantifier "The" and more than one is found).

\subsection{Changes to the interface}

I was responsible for adding any Javascript/HTML in order to add any functionality (such as search strategy selection, suggestions, or disambiguity). 

\section{Individual report: Carlos Tom\'e Cortiñas}
As I understand group work, this kind of project is meant not to be splitted 
in different parts and the join all together, but meeting and discussing every step
of the project so everybody contributes to it.  \\

This is how most part of the work was done, although some concrete parts were 
developed standalone.  \\

All parts of the project required a lot of testing and debugging, which I 
contributed a lot to.  \\

\subsection{Basic project}
In this part I was mostly responsible for the BFS planner, and the integration 
of the different modules. \\

\subsection{Extension: Quantifiers}
In this section, I was not directly involved in the developing, althoug I 
contributed with the testing, and debugging and In a small way on the high 
level ideas behind what we do.  \\

\subsection{Extension: Planning for bigger or more complex worlds}

In this part, I extended the planner to be able to handle A* search, replacing 
the queue used before in the fringe for a priority queue.  \\

As well I'm responsible for the design and implementation of the heuristic 
function which is the key part of this extension.  \\

\subsection{Extension: Suggestions}

This extension was developed between Robert, Santiago and me.  \\

\subsection{Extension: Disambiguity}

In this section I contributed in the high level ideas behind our way of 
uniquely identify an object in the world.  \\

\end{document}
