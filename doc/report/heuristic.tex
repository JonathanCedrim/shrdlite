In this extension, to make a more efficient search over the state-space, we implemented
a heuristics function, which given a world and the final goal evaluates how good is the
current world in order to achieve such goal.

As stated before we have to kinds of goals, composite and simple ones. In the case of
composite, this means that a goal can be either a conjunction of some other goals or 
the disjuntion of them.

We think its reasonable that when we have a conjuction of goals, the heuristic of this
is the maximum heuristic of the goals composing this goal, as we know at most we will need
perform the number of steps that requires the goal with the highest heuristic.

When the goal is a disjunction of some other goals, we need to at least achieve one of them and it makes sense to try to achieve the one with the less number of steps.

The real power of the heuristic function cames when we apply it to a simple goal of the form
MoveObj id1 rel id2, in this case we split up the heuristic depending on what relation 
must hold between the two ids.
  
The most interesting cases in this functions, are the ones involving the Ontop, Above and Leftof or Rightof relation. The other cases are simply derived from these.

case Ontop:

In this case as we need to put the first object directly on the second object, what we do is
calculate the heuristic in base of how many objects we need to move to free the object 1
and how many to free object 2. As every drop and pick counts as a simple action, to free an object we need two pick and drop all objects that are above it. Here the corner case arises when the object 1 is already Above the object 2, and so freeing object 1 reduces the number of objects you have to remove to free the object 2.

case Above:

This case is very similar to the previous one in the sense that we need to free object 1 to 
move it above object 2, but this time object 2 only need to be freed to the point where 
some object that is already above it can hold object 1.

As we design this heuristic, we tryied to make it admissible so A* algorithm will find always
the optimal solution.
